#!/usr/bin/perl -w

# Copyright (C) 2011 CNRS - Ecole Polytechnique - INRIA.
# 
# This file is part of TIFA.
#
# TIFA is free software; you can redistribute it and/or modify it under the 
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# TIFA is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.

#------------------------------------------------------------------------------
#                Automatic generation of plots from result files
#------------------------------------------------------------------------------
# File    : plotmaker.pl
# Author  : Jerome Milan
# Version : 2011-10-11
#
# This script will generate plotting macros and plots from a result file
# created by a benchmark perl script (as generated by the benchmarker.pl
# script).
#
# Several plots will be generated showing results for all combinations of the
# benched program's parameters making easy to identify the optimal parameter
# values for a given argument.
#------------------------------------------------------------------------------

use strict;
use Getopt::Long;
use File::Basename;
use Class::Struct;
use Tifa::DataDescriptor;
use Tifa::GnuPlotter;
use Tifa::Rotor;

#
# Available plotting modules and associated informations. For the time
# being, only the Tifa::GnuPlotter module is available.
#
my %plotting_modules = (
    "gnuplot" => "Tifa::GnuPlotter"
);

my %module_descriptions = (
    "gnuplot" => "Create gnuplot macros and plots using Tifa::GnuPlotter"
);

my %macro_extensions = (
    "gnuplot" => "gp"
);

my %plot_formats = (
    "gnuplot" => ["eps", "pdf", "png"]
);

#
# Options and default values if any.
#
my $input_file;
my $output_dir;
my $config_file      = "plotmaker.conf";
my $file_prefix      = "";
my $plotting_program = "gnuplot";
my $plot_format      = "pdf";
my $help;

GetOptions(
    "in=s"      => \$input_file,
    "outdir=s"  => \$output_dir,
    "conf=s"    => \$config_file,
    "prefix=s"  => \$file_prefix,
    "program=s" => \$plotting_program,
    "format=s"  => \$plot_format,
    "help"      => \$help
);

if ($help) {
    print_help();
}

&check_options_validity;

my @data_entries = ();

my $descriptor = new Tifa::DataDescriptor();

read_all_data($descriptor, $input_file, \@data_entries);

my @fields = $descriptor->get_all_field_names();

my %params_unique_values = ();

get_unique_values(\%params_unique_values, \@data_entries);

#
# The base directory for this given plot type.
#
my $type_dir   = "$output_dir/$plotting_program";
#
# The directory to hold the various datafiles for the plotting program.
#
my $data_dir   = "$type_dir/data";
#
# The directory to hold the various macros for the plotting program.
#
my $macro_dir  = "$type_dir/macro";
#
# The directory to hold the various plots for a given file format.
#
my $format_dir = "$type_dir/$plot_format";
#
# Stop if we cannot create all these directories.
#
if (! -e $output_dir) {
    mkdir($output_dir, 0700)
        or die("ERROR: Cannot create directory $output_dir!\n");
}
if (! -e $type_dir) {
    mkdir($type_dir, 0700)
        or die("ERROR: Cannot create directory $type_dir!\n");
}
if (! -e $data_dir) {
    mkdir($data_dir, 0700)
        or die("ERROR: Cannot create directory $data_dir!\n");
}
if (! -e $macro_dir) {
    mkdir($macro_dir, 0700)
        or die("ERROR: Cannot create directory $macro_dir!\n");
}
if (! -e $format_dir) {
    mkdir($format_dir, 0700)
        or die("ERROR: Cannot create directory $format_dir!\n");
}

#
# Plot description : describes a series of plot
#
# x      : The expression giving the abscissa of the plots
# y      : The expression giving the ordinate of the plots
# z      : The variable name of the parameter of the plots
# cond   : Extra conditionnal expression acting as a filter: the plots will be
#          generated considering only the data points verifying this condition
# params : List of variable names that has to be considered as fixed
#          parameters for a given plot. One plot is generated for each
#          combination of values of the variables named in the params array
# graph_title,
# x_axis_title,
# y_axis_title: self explanatory
#
struct PlotDesc => {
    x      => '$',
    y      => '$',
    z      => '$',
    cond   => '$',
    params => '@',
    graph_title  => '$',
    x_axis_title => '$',
    y_axis_title => '$'
};

#
# Get the list of the plots to generate.
#
my @plot_descr_array = read_plot_desc($config_file);
#
# Graph identifier (A zero padded string of numbers).
#
my $graph_id = -1;

#
# Generate the plots according to each PlotDesc structures.
#
foreach my $plot_desc (@plot_descr_array) {
    #
    # Determine which paramaters define a given plot (i.e. the constant
    # parameters)
    #
    my @plot_var_keys = ();
    foreach my $key (@{$plot_desc->params}) {
        if (! is_in_plot_desc($key, $plot_desc)) {
            push(@plot_var_keys, $key);
        }
    }
    #
    # Create the set of all possible combinations of all the involved
    # parameters.
    #
    my $combo_data_ref = create_all_combos(\@plot_var_keys,
                                           \%params_unique_values);

    my $id_width = scalar @$combo_data_ref;
    #
    # Generate restricted datafile (i.e. the data file for _this_ particular
    # plot) then generate and execute the plotting macro.
    #
    foreach my $fixed_set_ref (@$combo_data_ref) {

        my @x_array = ();
        my @y_array = ();
        my @z_array = ();

        foreach my $entry_ref (@data_entries) {
            #
            # Filter the data to keep only the one with the restricted values
            # for _this_ particular plot.
            #
            if (compare_hashes($entry_ref, $fixed_set_ref)) {

                if ($plot_desc->cond) {
                   #
                   # Check if this data point also satisfies the condidion
                   # given by $plot_desc->cond.
                   #
                   if (! eval_expression($plot_desc->cond, $entry_ref)) {
                       #
                       # Skip this data point since the condition is not
                       # satisfied and try the next $entry_ref.
                       #
                       next;
                   }
                }
                push(@x_array, eval_expression($plot_desc->x, $entry_ref));
                push(@y_array, eval_expression($plot_desc->y, $entry_ref));
                push(@z_array, eval_expression($plot_desc->z, $entry_ref));
            }
        }
        #
        # Skip this plot if it's going to be empty.
        #
        next if (scalar(@x_array) == 0);
        #
        # Split the main label in $nlines lines.
        #
        my $main_label = "";
        my $nlines = 2;
        my @varkeys = sort {$a cmp $b } (keys %$fixed_set_ref);
        my $key_cnt = @varkeys;
        my $nfields_per_line = int($key_cnt/$nlines + 0.5);

        for my $nline (0..($nlines - 2)) {
            for (my $i = $nline * $nfields_per_line;
                    $i < ($nline + 1) * $nfields_per_line;
                    $i++) {
                $main_label .= "$varkeys[$i]=$$fixed_set_ref{$varkeys[$i]}    ";
            }
            $main_label .= '\n';
        }
        for (my $i = ($nlines - 1) * $nfields_per_line;
                $i < $key_cnt;
                $i++) {
            $main_label .= "$varkeys[$i]=$$fixed_set_ref{$varkeys[$i]}    ";
        }
        $main_label =~ s/(\s)*\\n/\\n/g;
        $main_label =~ s/\\n$//g;
        #
        # Second label: Used to display the cut used to filter the data points.
        #
        my $cond_label = "Using cut: ";
        if (defined $plot_desc->cond) {
            $cond_label .= "(".$plot_desc->cond.")";
        } else {
            $cond_label .= "(none)";
        }
        #
        # $graph_id is an multi-digit, zero-padded identifier.
        #
        $graph_id++;
        my $graph_id_str = sprintf("%0$id_width".'d', $graph_id);
        #
        # Use a tag to "briefly" describe the plot.
        #
        my $graph_tag = $plot_desc->y."_vs_".$plot_desc->x;

        foreach my $vk (@varkeys) {
            $graph_tag .= "_$$fixed_set_ref{$vk}";
        }
        $graph_tag =~ s/\W//g; # Get rid of special characters

        #
        # Data filename for this particular plot.
        #
        my $data_file = "$data_dir/$file_prefix"."data_$graph_tag";
        $data_file   .= "_$graph_id_str.txt";
        #
        # Output macro file.
        #
        my $macro_file = "$macro_dir/$file_prefix"."macro_$graph_tag";
        $macro_file   .= "_$graph_id_str.txt";
        #
        # Output plot file.
        #
        my $plot_file = "$format_dir/$file_prefix"."$graph_tag";
        $plot_file   .= "_$graph_id_str.$plot_format";
        #
        # Everything is ready. Call a plotting module.
        #
        my $module = $plotting_modules{$plotting_program};
        my $plotter;

        eval("\$plotter = new $module();")
            or die("ERROR: Cannot create instance of $module!\n");

        $plotter->set_xvar_description($plot_desc->x, " ");
        $plotter->set_yvar_description($plot_desc->y, " ");
        $plotter->set_zvar_description($plot_desc->z, " ");

        $plotter->set_xvar_values(\@x_array);
        $plotter->set_yvar_values(\@y_array);
        $plotter->set_zvar_values(\@z_array);

        $plotter->set_xaxis_title($plot_desc->x_axis_title);
        $plotter->set_yaxis_title($plot_desc->y_axis_title);
        $plotter->set_graph_title($plot_desc->graph_title);
        $plotter->set_main_label($main_label);
        $plotter->set_second_label($cond_label);

        $plotter->set_data_filename($data_file);
        $plotter->set_macro_filename($macro_file);
        $plotter->set_output_filename($plot_file);

        $plotter->write_data_file();
        $plotter->generate_macro();
        $plotter->execute_macro();
    }
}

#------------------------------------------------------------------------------
# Functions
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
sub print_help {
    my $name = basename($0);

    my $title = "$name - Automatic generation of plots from result files";
    my $line  = '-' x length($title);
    print << "EOF";

$title
$line

EOF

    print("Usage:\n");
    print("------\n\n");
    printf("%15s --in <infile> --outdir <output dir> [--format <format>]\n",
           $name);

    printf("%15s [--program <plotting_program>] [--conf <config_file>]\n", "");
    printf("%15s [--prefix <prefix>] [--help]\n", "");

print << "EOF";

The $name script will generate plotting macros and plots from a result
file created by a benchmark perl script (as generated by the benchmarker.pl
script) and extracted using extractres.pl.

General parameters/options:
---------------------------

  --in=s
      (mandatory)
      Input file containing the benchmark results in a format understandable
      by the Tifa::DataDescriptor module. Scripts generated by
      extractres.pl follow that convention. See help for extractres.pl and
      the Tifa::DataDescriptor module for more information.

  --program=s
      (optional, default value used it none provided)
      Plot program to use. It actually defines which Tifa plotting module will
      be used to create the plots.
      Available programs:
EOF
    foreach my $prog (keys %module_descriptions) {
        print "          $prog : $module_descriptions{$prog}\n";
    }
print << 'EOF';
      Default: gnuplot

  --prefix=s
      (optional, default value used it none provided)
      Prefix used in naming the generated files:
         Data  : <prefix>data_xxxx.txt
         Macros: <prefix>macro_xxxx.macro_format
         Plots : <prefix>plot_xxxx.plot_format
      Default: "" (empty string)

  --conf=s
      (optional, default value used it none provided)
      Name of the configuration file describing the plots to generate.
      This configuration file should be written in pure Perl as it will be
      directly interpreted "as is". Each new plot description should be pushed
      in the (already defined) @pdesc_array array.
      Default: plotmaker.conf

      A plot description is a structure (in the Class:Struct sense) that
      describes a series of plot. Its member data are:

          x      : The expression giving the abscissa of the plots
          y      : The expression giving the ordinate of the plots
          z      : The variable name of the parameter of the plots
          cond   : Extra conditionnal expression acting as a filter: the
                   plots will be generated considering only the data points
                   verifying this condition
          params : List of variable names that has to be considered as fixed
                   parameters for a given plot. One plot is generated for each
                   combination of values of the variables named in the params
                   array
          graph_title :
          x_axis_title:
          y_axis_title: self explanatory

      The provided plotmaker.conf configuration file gives an example of the
      syntax used.

  --outdir=s
      (mandatory)
      Name of the output directory.
      Created files will be arranged in the following fashion:

      <output_dir>/<program>/data/:
          Contains the <program> data files for each individual plot.
      <output_dir>/<program>/macro/:
          Contains the <program> macros for each individual plot. There is
          a macro_xxxx.ext in this directory for each plot_xxxx.txt datafile
          in <output_dir>/<program>/data/, where x is a decimal digit.
          The macro extension 'ext' varies depending on which <program> is used.
      <output_dir>/<program>/<format>/:
          Depending of the output file format selected, contains the
          resulting plot_xxxx.format files, as created by the <program>
          macros macro_xxxx.ext in <output_dir>/<program>/macro/.

  --format=s
      (optional, default value used it none provided)
      File format for the various created plots.
      Available formats:
EOF
    foreach my $prog (keys %plot_formats) {
        print "            $prog program: ";

        for my $i (0..($#{$plot_formats{$prog}} - 1) ) {
            print "\"${$plot_formats{$prog}}[$i]\", ";
        }
        print "\"${$plot_formats{$prog}}[$#{$plot_formats{$prog}}]\"\n";
    }
print << "EOF";
      Default: pdf

  --help
      Prints this help...

EOF
    exit();
}
#------------------------------------------------------------------------------
sub read_all_data {
    #
    # Reads all the data entries in the file $filename and stores them as a
    # reference to a hashtable in the array referenced by $arrayref.
    #
    my $descr    = shift(@_);
    my $filename = shift(@_);
    my $arrayref  = shift(@_);

    $descr->set_comment_style("Perl");
    open(my $handle, "<$filename") or die("Cannot open $filename\n");
    $descr->load_descriptions($handle);
    my $nkeys = 1;
    while ($nkeys != 0) {
        my %entry = $descr->read_next_data_entry($handle);
        $nkeys = scalar(keys %entry);
        if ($nkeys != 0) {
            push(@$arrayref, \%entry);
        }
    }
    close($handle);
}
#------------------------------------------------------------------------------
sub is_in_plot_desc {
    #
    # Checks if the field $varname appears in any field of the PlotDesc stucture
    # given by $plot_desc. This is used to check which parameters should be
    # considered as constants for a particular plot.
    #
    my $varname   = shift(@_);
    my $plot_desc = shift(@_);

    #
    # Check if the variable named $varname appears in the expression
    # giving the abscissa of the plot
    #
    my $pdesc_field = $plot_desc->x;
    if ($pdesc_field =~ m/$varname/) {
        return 1;
    }
    #
    # Check if the variable named $varname appears in the expression
    # giving the ordinate of the plot
    #
    $pdesc_field = $plot_desc->y;
    if ($pdesc_field =~ m/$varname/) {
        return 1;
    }
    #
    # Check if the variable named $varname appears in the expression
    # giving the variable parameter of the plot
    #
    $pdesc_field = $plot_desc->z;
    if ($pdesc_field =~ m/$varname/) {
        return 1;
    }
    #
    # Do not make separate plots for any variable appearing in the
    # conditionnal expression...
    #
    if (defined $plot_desc->cond) {

        $pdesc_field = $plot_desc->cond;
        if ($pdesc_field =~ m/$varname/) {
            return 1;
        }
    }
    return 0;
}
#------------------------------------------------------------------------------
sub create_all_combos {
    #
    # Make a data set containing each possible combinations of values of the
    # parameters...
    #
    my $params_ref      = shift(@_);
    my $unique_vals_ref = shift(@_);

    my @data_set = ();

    my @sizes = ();
    foreach my $param (@$params_ref) {
        push(@sizes, scalar @{$$unique_vals_ref{$param}});
    }

    my $rotor = new Tifa::Rotor(@sizes);

    do {
        my @ntuple = $rotor->get_state();
        my %values = ();

        foreach my $i (0 .. scalar(@ntuple)-1) {
            my $parname = $$params_ref[$i];
            $values{$parname} = $$unique_vals_ref{$parname}[$ntuple[$i]];
        }
        push(@data_set, \%values);

        $rotor->increment();

    } while (! $rotor->is_zero);

    return \@data_set;
}
#------------------------------------------------------------------------------
sub get_unique_values {
    #
    # Reads all of the data entries referenced by the array
    # @{$entries_array_ref} and stores in the hashtable %{$unique_hash_ref}
    # the map between the parameter names and a list of all of the _different_
    # values taken by this parameter. In other words no value will be duplicated
    # in the lists.
    #
    my $unique_hash_ref   = shift(@_);
    my $entries_array_ref = shift(@_);
    my %tmp_unique        = ();

    foreach my $hash_ref (@$entries_array_ref) {
        foreach my $key (keys %$hash_ref) {
            ${$tmp_unique{$key}}{$$hash_ref{$key}} = 1;
        }
    }
    foreach my $key (keys %tmp_unique) {
        @{$$unique_hash_ref{$key}} = (keys %{$tmp_unique{$key}});
    }
}
#------------------------------------------------------------------------------
sub check_options_validity {

    if (! $input_file) {
        print("ERROR: No input file provided!\n");
        exit();
    }
    if (! -e $input_file) {
        print("ERROR: Cannot find input file $input_file !\n");
        exit();
    } elsif (! -r $input_file) {
        print("ERROR: Cannot read input file $input_file !\n");
        exit();
    }
    if (! $config_file) {
        print("ERROR: No configuration file provided!\n");
        exit();
    }
    if (! -e $config_file) {
        print("ERROR: Cannot find configuration file $config_file !\n");
        exit();
    } elsif (! -r $config_file) {
        print("ERROR: Cannot read configuration file $config_file !\n");
        exit();
    }
    if (! $output_dir) {
        print("ERROR: No output directory provided!\n");
        exit();
    }
    if (-e $output_dir) {
        if (! -d $output_dir) {
            print("ERROR: $output_dir is not a directory!\n");
            exit();
        }
    }
    if (! exists $plotting_modules{$plotting_program}) {
        print("ERROR: $plotting_program is not a valid plotting program!\n");
        exit();
    }
    my $module = $plotting_modules{$plotting_program};
    my $to_eval = '%{'.$module.'::allowed_output_format}';
    my %allowed = eval($to_eval);

    if (! exists $allowed{$plot_format}) {
        print("ERROR: format $plot_format not allowed with"
                     ." $plotting_program!\n");
        exit();
    }
}
#------------------------------------------------------------------------------
sub eval_expression {
    #
    # Evaluate the expression $expr using the data given by $entryref, an
    # hashtable reference.
    #
    my $expr     = shift(@_);
    my $entryref = shift(@_);

    foreach my $field (keys %$entryref) {
        my $value = $$entryref{$field};
        if (! defined $value) {
            print("ERROR: parameter $field unknown.");
            print(" Check configuration file for possible typos.\n");
            exit();
        }
        $expr =~ s/\b$field\b/$value/g;
    }
    return eval($expr);
}
#------------------------------------------------------------------------------
sub compare_hashes {
    #
    # Returns 1 if the values of %{$hash_b_ref} are the same as the values
    # of %{$hash_a_ref}, for all the keys of the %{$hash_b_ref} hashtable.
    #
    # Return 0 otherwise.
    #
    my $hash_a_ref = shift(@_);
    my $hash_b_ref = shift(@_);

    foreach my $key (keys %$hash_b_ref) {
        next if (! exists $$hash_a_ref{$key});
        if ($$hash_a_ref{$key} != $$hash_b_ref{$key}) {
            return 0;
        }
    }
    return 1;
}
#------------------------------------------------------------------------------
sub read_plot_desc {
    #
    # The descriptions of the desired plots are given in a configuration file
    # whose content is directly executed as regular Perl code...
    #
    my $conf_file   = shift(@_);
    my @pdesc_array = ();
    my $pdesc;
    my $rcode;
    #
    # Read the configuration file and store its content in the array
    # conflines so that we can evaluate it
    #
    open(IN, "<$conf_file") or die("Cannot read configuration file!\n");
    my @conflines = <IN>;
    close(IN);
    #
    # Parse and execute the content of the configuration file. This has the same
    # effect as if the code appeared verbatim in this subroutine.
    #
    unless ($rcode = scalar eval("@conflines")) {
        die("ERROR: Cannot compile $conf_file: $@\n") if ($@);
        die("ERROR: Cannot read $conf_file: $!\n")    unless (defined $rcode);
    }
    return @pdesc_array;
}
#------------------------------------------------------------------------------
