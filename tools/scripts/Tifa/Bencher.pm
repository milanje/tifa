package Tifa::Bencher;

# Copyright (C) 2011 CNRS - Ecole Polytechnique - INRIA.
# 
# This file is part of TIFA.
#
# TIFA is free software; you can redistribute it and/or modify it under the 
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# TIFA is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.

#------------------------------------------------------------------------------
#                    A general benchmarking framework.
#------------------------------------------------------------------------------
# File    : Bencher.pm
# Author  : Jerome Milan
# Version : 0.1
#
# The Tifa::Bencher module implements a general purpose benchmark framework.
# Given a program and a set of parameters, it can generate a benchmark perl
# script using every combination of the parameters values.
#------------------------------------------------------------------------------

use 5.006002;
use strict;
use warnings;
use Fcntl;
use File::Basename;
use Carp;

use Tifa::ProgramRepository;
use Tifa::Rotor;

require Exporter;

our @ISA        = qw(Exporter);
our @EXPORT_OK  = qw();
our $VERSION    = '0.1';

#------------------------------------------------------------------------------
sub new {
    my $type = shift(@_);
    my $self = {};

    $self->{args_file}    = "";
    $self->{output_dir}   = "";
    $self->{filter}       = "";
    $self->{param_names}  = ();
    $self->{param_values} = ();

    bless $self, $type;

    return $self;
}
#------------------------------------------------------------------------------
sub set_output_dir {
    my $self    = shift;
    my $outdir  = shift;
    $self->{output_dir} = $outdir;
}
#------------------------------------------------------------------------------
sub get_output_dir {
    my $self = shift;
    return $self->{output_dir};
}
#------------------------------------------------------------------------------
sub set_args_file {
    my $self    = shift;
    my $argfile = shift;
    $self->{args_file} = $argfile;
}
#------------------------------------------------------------------------------
sub get_args_file {
    my $self = shift;
    return $self->{args_file};
}
#------------------------------------------------------------------------------
sub set_param_values {
    my $self    = shift;
    my $parvals = shift;

    %{$self->{param_values}} = %$parvals;
    @{$self->{param_names}}  = keys %$parvals;
}
#------------------------------------------------------------------------------
sub get_param_values {
    my $self    = shift;
    return $self->{param_values};
}
#------------------------------------------------------------------------------
sub set_filter {
    my $self   = shift;
    my $filter = shift;

    if ((!defined $filter) || ($filter =~ /^\s*$/)) {
        $filter = "1";
    }
    $self->{filter} = $filter;
}
#------------------------------------------------------------------------------
sub get_filter {
    my $self = shift;
    return $self->{filter};
}
#------------------------------------------------------------------------------
sub create_bench_macro {
    my $self       = shift;
    my $macro_file = shift;

    my $output_dir = $self->{output_dir};

    my $date = localtime();

    sysopen(OF, "$macro_file", O_CREAT|O_WRONLY, 0700)
    or croak( "ERROR: Bencher::create_bench_macro: Cannot create file "
             .$macro_file);

    print OF << "EOF";
#!/usr/bin/perl -w

use strict;
use File::Copy;
use File::Basename;
use Tifa::DataDescriptor;
#
# File    : $macro_file
# Author  : Automatically generated by Tifa::Bencher::create_bench_macro
# Date    : $date
#
my \$script_name  = basename(\$0);
my \$output_dir   = \"$output_dir\";
my \$trace_dir    = \"\$output_dir/traces\";

my \$result_file  =  \"\$script_name\";
\$result_file     =~ s/(\.)[^\.]*\$//;
\$result_file    .=  \"_results.txt\";

#
# Built-in time command in bash or zsh. Users of other shells should
# use the time program, usually found at /usr/bin/time or /bin/time
# and change the invocation command accordingly. Note than you may then
# have to spawn a subshell to properly redirect the factoring program's
# stdout and stderr to the trace file while redirecting time's stderr to
# stdout...
#
my \$time_cmd = \"time -p\";

my \@jobs  = ();
my \@rslts = ();

my \$info_sep = ':';

if (! -e \$output_dir) {
    mkdir(\$output_dir, 0700)
        or die("ERROR: Cannot create directory \$output_dir!\\n");
}
if (! -e \$trace_dir) {
    mkdir(\$trace_dir, 0700)
        or die("ERROR: Cannot create directory \$trace_dir!\\n");
}

EOF

    #
    # Replace all scalars in the hash values by references to arrays containing
    # only one value (the scalar replaced)
    #
    __prepare_param_values__($self->{param_values});
    #
    # Now the %$self->{param_values} hash only contains references to arrays
    #
    $self->{params_involved} = $self->__get_params_involved__();

    my %param_to_descr
                = Tifa::ProgramRepository::get_all_param_to_descrs_hash();

    (my $cmd_pfx_ref, my $rslt_lines_ref) = $self->__get_bench_cmd_prefixes__();

    my @cmd_prefixes = @$cmd_pfx_ref;
    my @result_lines = @$rslt_lines_ref;

    my $width = length $#cmd_prefixes;

    foreach my $i (0 .. $#cmd_prefixes) {
        my $tag = sprintf("%0"."$width"."d", $i).".txt";

        my $full_cmd = "$cmd_prefixes[$i] > \$trace_dir/trace_$tag";
        my $full_cmd_print = "$cmd_prefixes[$i] > ";
        $full_cmd_print   .= "$output_dir/traces/trace_$tag";

        print("Command to bench:($full_cmd_print)\n");

        print OF "push(\@jobs,  \"$full_cmd\");\n";
        print OF "push(\@rslts, \"".$result_lines[$i]."\");\n";
    }

    print OF <<'EOF';

open(RF, ">>$output_dir/$result_file")
    or die("ERROR: Cannot open $output_dir/$result_file!");

my $localtime = localtime();

print RF <<"EOHD";

#
# File:   $result_file
# Author: Automatically generated by $script_name
# Date:   $localtime;
#
EOHD

my $descr = new Tifa::DataDescriptor();
$descr->set_comment_style("Perl");
$descr->set_field_separator("$info_sep");

$descr->add_field_description("algo",  "Algorithm used");
$descr->add_field_description("mode",  "Program mode used");
$descr->add_field_description("argmt", "Argument passed to program");
EOF

    foreach my $param (@{$self->{params_involved}}) {
        print OF "\$descr->add_field_description(\"$param\", \"";
        print OF $param_to_descr{$param}, "\");\n"
    }

    print OF <<'EOF';

$descr->add_field_description("real", "Real time spent");
$descr->add_field_description("user", "User time spent");
$descr->add_field_description("sys",  "System time spent");

my $handle = *RF;

$descr->write_descriptions(\$handle);

print RF "\n";

for (my $i = 0; $i < $#jobs+1; $i++) {

    my @timings = ();

    my $command = "{ $time_cmd $jobs[$i] 2>&1 ; } 2>&1";
    #
    # Launch job and get timings...
    #
    my $timing = `$command`;

    print RF ("#\n# Entry added on ".localtime()."\n#\n");

    #
    # Parse and interpret results...
    #
    $timing =~ s/(\s)+/\ /g;
    if ($timing =~ m/\D*(\d+\.\d+)\D*(\d+\.\d+)\D*(\d+\.\d+)/) {
        push(@timings, $1, $2, $3);
    } else {
        push(@timings, -1, -1, -1);
    }
    print_entry($handle, $rslts[$i], @timings);
}
close(RF);

move($script_name, "$output_dir/$script_name");

#------------------------------------------------------------------------------
# Functions
#------------------------------------------------------------------------------
sub print_entry {
    my $handle = shift(@_);
    my $info = shift(@_);
    my @timings = @_;

    my @vals = split(/:/, $info);
    push(@vals, @timings);

    $descr->write_data_entry($handle, @vals);
}
#------------------------------------------------------------------------------

EOF
    close(OF);
}
#------------------------------------------------------------------------------
sub __get_params_involved__ {
    my $self    = shift;

    my @programs        = ();
    my %algo_to_program = ();
    my $program;

    %algo_to_program = Tifa::ProgramRepository::get_algo_to_program_hash();
    @programs        = values %algo_to_program;
    #
    # We want to get all the parameters involved in one way or another, before
    # generating the information that will go in the result file...
    #
    my %all_params = ();

    foreach my $exe (@{$self->{param_values}{"exe"}}) {

        my $program = Tifa::ProgramRepository::get_program_from_name($exe);

        next if (! defined $program);
        #
        # Determines the program modes to benchmark
        #
        my %allowed_modes = map {$_, 1} $program->get_all_modes();
        my %mode_list     = ();

        $mode_list{$program->get_default_mode} = 1;

        if (defined $self->{param_values}{"mode"}) {
            foreach my $mode (@{$self->{param_values}{"mode"}}) {
                if (exists $allowed_modes{$mode}) {
                    if (! exists $mode_list{$mode}) {
                        $mode_list{$mode} = 1;
                    }
                }
            }
        }
        foreach my $mode (keys %mode_list) {
            $program->set_mode($mode);
            my @this_params = $program->get_param_names();
            foreach my $param (@this_params) {
                if (! exists $all_params{$param}) {
                    $all_params{$param} = 1;
                }
            }
        }
    }
    return [sort keys %all_params];
}
#------------------------------------------------------------------------------
sub __get_bench_cmd_prefixes__ {
    my $self = shift;

    my @programs        = ();
    my %algo_to_program = ();
    my $program;

    %algo_to_program = Tifa::ProgramRepository::get_algo_to_program_hash();
    @programs        = values %algo_to_program;

    @{$self->{param_values}{"args"}}
                                = __get_args_from_file__($self->{args_file});

    my @command_prefixes = ();
    my @result_lines     = ();

    foreach my $argmt (@{$self->{param_values}{"args"}}) {

        foreach my $exe (@{$self->{param_values}{"exe"}}) {

            my $program = Tifa::ProgramRepository::get_program_from_name($exe);

            next if (! defined $program);

            $program->set_exe($exe);

            #
            # Determines the program modes to benchmark
            #
            my %allowed_modes = map {$_, 1} $program->get_all_modes();
            my %mode_list     = ();

            if (defined $self->{param_values}{"mode"}) {
                foreach my $mode (@{$self->{param_values}{"mode"}}) {
                    if (exists $allowed_modes{$mode}) {
                        if (! exists $mode_list{$mode}) {
                            $mode_list{$mode} = 1;
                        }
                    }
                }
            }

            foreach my $mode (keys %mode_list) {

                $program->set_mode($mode);

                my @params = $program->get_param_names();

                my @sizes = ();
                foreach my $param (@params) {                    
                    push(@sizes, scalar @{$self->{param_values}{$param}});
                }
                my $rotor = new Tifa::Rotor(@sizes);

                do {
                    my @ntuple = $rotor->get_state();
                    my %values = ();

                    foreach my $i (0 .. scalar(@ntuple)-1) {
                        my $parname = $params[$i];
                        $values{$parname}
                        = $self->{param_values}{$parname}[$ntuple[$i]];
                    }

                    if ($self->__eval_expression__($program, \%values)) {

                        my $cmd  = $program->make_cmd(\%values, $argmt);
                        my $resl = $program->get_algo().":$mode:$argmt:";

                        foreach my $param (@{$self->{params_involved}}) {
                            if (defined $values{$param}) {
                                $resl .= $values{$param};
                            } else {
                                $resl .= "-1";
                            }
                            $resl .= ":";
                        }
                        push(@command_prefixes, $cmd);
                        push(@result_lines, $resl);
                    }
                    $rotor->increment();

                } while (! $rotor->is_zero);
            }
        }
    }
    return (\@command_prefixes, \@result_lines);
}
#------------------------------------------------------------------------------
sub __eval_expression__ {
    my $self     = shift(@_);
    my $program  = shift(@_);
	my $entryref = shift(@_);
	my $expr     = $self->{filter};

	my $value;

	foreach my $field (keys %$entryref) {
        $value = $$entryref{$field};
        $expr =~ s/\b$field\b/$value/g;
    }
    $value = $program->get_exe();
    $expr =~ s/\bexe\b/\"$value\"/g;

    $value = $program->get_algo();
    $expr =~ s/\balgo\b/\"$value\"/g;

    $value = $program->get_mode();
    $expr =~ s/\bmode\b/\"$value\"/g;

	return eval($expr);
}
#------------------------------------------------------------------------------
sub __prepare_param_values__ {
    my $hashref = shift;
    #
    # If a value of the hashtable is a scalar, wraps this value in an array
    # and replace it by a reference to this array
    #
    foreach my $key (keys %{$hashref}) {
        my $reftype = ref($$hashref{$key});
        if (!$reftype) {                          # $hashref{$key} is a scalar
            $$hashref{$key} = [$$hashref{$key}];
            next;
        }
        if ($reftype ne "ARRAY") {  # $hashref{$key} is not a ref to an array
            croak( "ERROR: Bencher: for now, only arrays and scalars "
                  ."are allowed in the configuration file");
        }
        #
        # Remove duplicate values in arrays referenced in the hash
        #
        my %hashtmp     = map {$_, 1} @{$$hashref{$key}};
        $$hashref{$key} = [sort keys %hashtmp];
    }
}
#------------------------------------------------------------------------------
sub __get_args_from_file__ {
    my $argfile = shift;
    my @argmts  = ();

    open(IN, "<$argfile") or croak("ERROR: Bencher: Cannot open file $argfile");
    while (my $line = <IN>) {
        next if ($line =~ m/^(\s)*$/);     # Skip blank lines...
        next if ($line =~ m/^(\s)*\#.*$/); # Skip comments...

        chomp($line);      # Suppress trailing newline
        $line =~ s/^\D*//; # Suppress leading non digit characters
        $line =~ s/\D*$//; # Suppress trailing non digit characters
        $line =~ s/#.*//;  # Suppress in-line comments

        push(@argmts, $line);
    }
    close(IN);

    return @argmts;
}
#------------------------------------------------------------------------------

1;

__END__

#------------------------------------------------------------------------------
# Stub documentation for this module.
#------------------------------------------------------------------------------

=head1 NAME

Tifa::Bencher - A general purpose benchmark module

=head1 SYNOPSIS

  use Tifa::Bencher;
  $program = new Tifa::Bencher();

=head1 REQUIRE

Perl 5.006002, Carp, Exporter, Tifa::ProgramRepository and Tifa::Rotor.

=head1 SUMMARY

The Tifa::Bencher module implements a general purpose benchmark framework.
Given a program and a set of parameters, it can generate a benchmark perl
script using every combination of the parameters values.

=head1 DESCRIPTION

The Tifa::Bencher module implements a general purpose benchmark framework and
is used in the TIFA library by the benchmarker.pl script to benchmark the
various factorization programs for a wide selection of parameters values.

A Tifa::Bencher object takes its parameters (including the name of the program
to benchmark) from a hashtable mapping each parameter name to its value or to
an array of values (to perform benchmarks for different values of a given
parameter). It can then generate a Perl script listing all of the commands to
execute, that is to say, all the invocations of the program to benchmark for
every possible combination of the parameter values. The generated script should
then be launched manually to proceed to the benchmarks.

Note that the key 'exe' must appear in this hashtable since its associated
value(s) give(s) the name(s) of the program(s) to benchmark. Additionally,
the program to benchmark should be wrapped in a Tifa::Program object and
registered in the Tifa::ProgramRepository module to be useable (this is
the case for all of the TIFA's factorization programs).

=head2 Data members

A Bencher object is defined by the following attributes:

    $args_file    : Name of the argument file.

    $output_dir   : Name of the ouput directory where bench results will
                    be saved

    $filter       : Perl-like conditional expression used to decide
                    whether or not the program should be benchmarked
                    with a particular combination of parameters.

    %param_values : Hashtable mapping each parameter name to its value
                    or to an array of values. The 'exe' key is mandatory
                    since its associated value gives the name of the
                    program to benchmark.

=head2 Available methods

    new()
    set_output_dir($outdir)
    get_output_dir()
    set_args_file($filename)
    get_args_file()
    set_param_values($hash_ref)
    get_param_values()
    set_filter($expression)
    get_filter()
    create_bench_macro($outfile)

=head2 Methods description

    new()
        Basic constructor allocating a Tifa::Bencher object.

    set_output_dir($outdir)
        Sets the name of the output directory. Trace files will be saved
        under $outdir/traces as trace_xxxx.txt with xxxx being a unique
        integer identifier.

    get_output_dir()
        Returns the name of the ouput directory.

    set_args_file($filename)
        Sets the name of the argument file.

    get_args_file()
        Returns the name of the argument file.

    set_param_values($hash_ref)
        Sets the values of the parameters relevant to the program to
        bench. $hash_ref is a reference to a hashtable mapping each
        parameter name to its value or to an array of values. In
        particular, the name(s) and the mode(s) (see documentation for
        Tifa::Program) of the program to benchmark should be given in
        this hashtable.

    get_param_values()
        Returns a reference to a hashtable mapping each parameter
        name to its value or to an array of values.

    set_filter($expression)
        Sets the conditional expression used to decide whether or not
        the program should be benchmarked with a particular combination
        of parameters. $expression should follow Perl's syntax and use
        parameter names as given by 'set_param_values'. In addition to
        these parameter names, the parameters 'algo', 'exe' and 'mode'
        are allowed.

    get_filter()
        Returns the current filter as a string.

    create_bench_macro($outfile)
        Creates a Perl script named $outfile containing all the program
        invocations to benchmark. The created script is not executed and
        should consequently be launched manually to proceed to the real
        benchmarks.

=head1 EXAMPLE

The best example of how to use the Tifa::Bencher module is given by the
benchmarker.pl script, so it is strongly advised to have a look at
benchmarker.pl's documentation.

Here's another toy example of the Tifa::bencher module used to benchmark
TIFA's implementation of the SQUFOF algorithm for several numbers of trial
divisions. Note that this implementation is registered in the
Tifa::ProgramRepository module with the name 'squfof_program'.

  $bencher = new Tifa::Bencher;

  #
  # Create an argument file containing some numbers to factors.
  #
  $argfile = "numbers.txt";

  open(OUT, ">$argfile") or die("Cannot open $argfile");
  print OUT "816379";
  print OUT "123465";
  close(OUT);

  #
  # Parameter hashtable
  #
  %params = (
      'exe'          => './squfof_program',
      'nprimes_tdiv' => [15, 30, 45]
  );

  $bencher->set_args_file($argfile);
  $bencher->set_output_dir("benchs");
  $bencher->set_param_values(\%params);
  $bencher->set_filter("nprimes_tdiv >= 30");

  $bencher->create_bench_macro("test.pl");

  #
  # The generated test.pl script will execute the following commands:
  #
  #     ./squfof_program 30 816379 > benchs/traces/trace_0.txt
  #     ./squfof_program 45 816379 > benchs/traces/trace_1.txt
  #     ./squfof_program 30 123465 > benchs/traces/trace_2.txt
  #     ./squfof_program 45 123465 > benchs/traces/trace_3.txt
  #
  # Note that the commands:
  #
  #     ./squfof_program 15 816379 > benchs/traces/...
  #     ./squfof_program 15 123465 > benchs/traces/...
  #
  # will not be executed since the conditional expression passed to the
  # function set_filter is not satisfied for these parameter values.
  #

=head1 EXPORT

No functions are exported from this package by default.

=head1 SEE ALSO

The benchmarker.pl script and the Tifa::Program and Tifa::ProgramRepository
modules.

=head1 AUTHOR

Jerome Milan, E<lt>milanje at gmail dot comE<gt>

=head1 VERSION

0.1.0

=head1 COPYRIGHT AND LICENSE

INCLUDE_LICENSE_AS_TEXT

=cut
